# -*- encoding: utf-8 -*-
##############################################################################
#
#    Copyright (C) 2014 Compassion CH (http://www.compassion.ch)
#    Releasing children from poverty in Jesus' name
#    @author: Emanuel Cino <ecino@compassion.ch>
#
#    The licence is in the file __openerp__.py
#
##############################################################################

from openerp import api, exceptions, fields, models, _
from openerp.tools import mod10r

from openerp.addons.sponsorship_compassion.model.product import \
    GIFT_CATEGORY, GIFT_NAMES, SPONSORSHIP_CATEGORY

import time


class AccountStatement(models.Model):

    """ Adds a relation to a recurring invoicer. """

    _inherit = 'account.bank.statement'

    ##########################################################################
    #                                 FIELDS                                 #
    ##########################################################################

    recurring_invoicer_id = fields.Many2one(
        'recurring.invoicer', 'Invoicer')
    generated_invoices_count = fields.Integer('Invoices',
                                              compute='_count_invoices')

    ##########################################################################
    #                             FIELDS METHODS                             #
    ##########################################################################

    @api.one
    @api.depends('recurring_invoicer_id')
    def _count_invoices(self):
        self.generated_invoices_count = len(
            self.recurring_invoicer_id.invoice_ids)

    ##########################################################################
    #                             PUBLIC METHODS                             #
    ##########################################################################

    @api.multi
    def to_invoices(self):
        self.ensure_one()
        return {
            'name': 'Generated Invoices',
            'view_mode': 'tree,form',
            'view_type': 'form',
            'res_model': 'account.invoice',
            'domain': [('recurring_invoicer_id', '=',
                        self.recurring_invoicer_id.id)],
            'type': 'ir.actions.act_window',
            'target': 'current',
            'context': {'form_view_ref': 'account.invoice_form',
                        'journal_type': 'sale'},
        }

    @api.one
    def button_invoices(self):
        invoicer_id = self.recurring_invoicer_id.id

        return {
            'name': 'Generated Invoices',
            'view_mode': 'tree,form',
            'view_type': 'form',
            'res_model': 'account.invoice',
            'domain': [('recurring_invoicer_id', '=', invoicer_id)],
            'type': 'ir.actions.act_window',
            'target': 'current',
            'context': {'form_view_ref': 'account.invoice_form',
                        'journal_type': 'sale'},
        }

    @api.multi
    def button_confirm_bank(self):
        """Confirm invoices generated by statment lines."""
        res = super(AccountStatement, self).button_confirm_bank()
        for statement in self:
            invoices = statement.line_ids.mapped('invoice_id')
            invoices.signal_workflow('invoice_open')
        return res

    @api.multi
    def button_cancel(self):
        """ Cancel invoices generated by statement lines. """
        res = super(AccountStatement, self).button_cancel()
        invoices = self.mapped('line_ids.invoice_id')
        invoices.action_cancel_draft()
        return res


class AccountStatementLine(models.Model):
    """ Adds products to statement lines to generate invoices. """

    _inherit = 'account.bank.statement.line'

    ##########################################################################
    #                                 FIELDS                                 #
    ##########################################################################

    already_completed = fields.Boolean('Auto-completed', readonly=True)

    ##########################################################################
    #                             PRIVATE METHODS                            #
    ##########################################################################

    @api.one
    def _create_invoice_from_line(self):
        # Get the attached recurring invoicer
        invoicer = self.statement_id.recurring_invoicer_id
        invoice_obj = self.env['account.invoice']
        if not invoicer:
            invoicer_obj = self.env['recurring.invoicer']
            invoicer = invoicer_obj.create({'source': self._name})
            self.statement_id.write(
                {'recurring_invoicer_id': invoicer.id})

        # Generate a unique bvr_reference
        ref = self.ref
        if not ref or len(ref) < 26:
            ref = mod10r((self.date.replace('-', '') + str(
                self.statement_id.id) + str(self.id)).ljust(26, '0'))

        # Lookup for an existing open invoice matching the criterias
        invoices = self._find_open_invoice()
        if invoices:
            # Get the bvr reference of the invoice or set it
            invoice = invoices[0]
            invoice.write({'recurring_invoicer_id': invoicer.id})
            if invoice.bvr_reference and not self.ref:
                ref = invoice.bvr_reference
            else:
                invoice.write({'bvr_reference': ref})
            self.write({
                'ref': ref,
                'invoice_id': invoice.id})
            return True

        # Setup a new invoice if no existing invoice is found
        journal = self.env['account.journal'].search(
            [('type', '=', 'sale')], limit=1)
        payment_term_ids = self.env['account.payment.term'].with_context(
            lang='en_US').search([('name', '=', 'Bank Transfer')]).ids
        inv_data = {
            'account_id': self.partner_id.property_account_receivable.id,
            'type': 'out_invoice',
            'partner_id': self.partner_id.id,
            'journal_id': journal.id if journal else False,
            'date_invoice': self.date,
            'payment_term': payment_term_ids and payment_term_ids[0] or 1,
            'bvr_reference': ref,
            'recurring_invoicer_id': invoicer.id,
            'currency_id': self.statement_id.currency.id,
        }
        if self.product_id.name == GIFT_NAMES[0] and self.contract_id \
                and self.contract_id.child_id and \
                self.contract_id.child_id.birthdate:
            inv_data['date_invoice'] = self.pool.get(
                'generate.gift.wizard').compute_date_birthday_invoice(
                self.contract_id.child_id.birthdate, self.date)
        invoice = invoice_obj.create(inv_data)

        inv_line_data = {
            'name': self.name,
            'account_id': self.product_id.property_account_income.id,
            'price_unit': self.amount,
            'price_subtotal': self.amount,
            'contract_id': self.contract_id and
            self.contract_id.id or False,
            'user_id': self.user_id and self.user_id.id or False,
            'quantity': 1,
            'uos_id': False,
            'product_id': self.product_id.id,
            'partner_id': self.partner_id.id,
            'invoice_id': invoice.id,
        }

        if self.product_id.categ_name in (GIFT_CATEGORY,
                                          SPONSORSHIP_CATEGORY) and not \
                self.contract_id:
            raise exceptions.Warning(_('A field is required'),
                                     _('Add a Sponsorship'))

        if self.analytic_account_id:
            inv_line_data['account_analytic_id'] = \
                self.analytic_account_id.id
        else:
            analytic = self.pool.get('account.analytic.default').account_get(
                self.env.cr, self.env.user.id, self.product_id.id,
                self.partner_id.id, self.env.user.id,
                time.strftime('%Y-%m-%d'), context=self.env.context)
            if analytic and analytic.analytic_id:
                inv_line_data['account_analytic_id'] = analytic.analytic_id.id

        self.env['account.invoice.line'].create(inv_line_data)

        invoice.button_compute()
        self.write({
            'ref': ref,
            'invoice_id': invoice.id})

        return True

    def _find_open_invoice(self):
        """ Find an open invoice that matches the statement line and which
        could be reconciled with. """
        invoice_line_obj = self.env['account.invoice.line']
        invoice_lines = invoice_line_obj.search([
            ('partner_id', '=', self.partner_id.id),
            ('state', 'in', ('open', 'draft')),
            ('product_id', '=', self.product_id.id),
            ('invoice_id.account_id', '=', self.account_id.id),
            ('price_subtotal', '=', self.amount)])
        invoices = invoice_lines.mapped('invoice_id').filtered(
            lambda inv: inv.amount_total == self.amount)

        return invoices
